#!/usr/bin/env python3

import sys
import json

## 
## PARSING DICTIONARY TO LANGUAGE INSTRUCTIONS LOGIC:
##
class CodeClass:
    def __init__(self, indentationCharacter, language, constKeyword):
        self.indentationCharacter = indentationCharacter
        self.language = language
        self.constKeyword = constKeyword
        self.indentationLevel = 0
        self.name = "Unknown"
        self.innerClasses = []
        self.attributeLines = []

    def createInnerClass(self):
        return 0
            
    def parseClassObject(self, jsonObject):
        self.name = jsonObject["className"]
        properties = jsonObject["classProperties"]

        for key in properties:
            value = properties[key]
            if (isinstance(value, str)):
                self.attributeLines.append(("%s %s = \"%s\"" % (self.constKeyword, key, value)))
            elif (isinstance(value, float)):
                self.attributeLines.append(("%s %s = %.2f" % (self.constKeyword, key, value)))
            elif (isinstance(value, int)):
                self.attributeLines.append(("%s %s = %d" % (self.constKeyword, key, value)))
            elif (isinstance(value, object)):
                innerClass = self.createInnerClass()
                innerClass.indentationLevel = self.indentationLevel + 1
                innerClass.parseClassObject(value)
                self.innerClasses.append(innerClass)
                self.attributeLines.append(("%s %s = %s()" % (self.constKeyword, key, innerClass.name)))
    
    def generateClassDefinitionLines(self):
        lines = []

        def indentation(level):
            ident = ""
            for i in range(0,level):
                ident = "%s%s" % (ident, self.indentationCharacter)
            return ident

        def writeLine(line, level):
            lines.append("%s%s" % (indentation(level), line))

        writeLine("class %s {" % self.name, self.indentationLevel)
        
        for attributeLine in self.attributeLines:
            writeLine(attributeLine, self.indentationLevel + 1)

        if (len(self.innerClasses) > 0):
            writeLine("", self.indentationLevel)
            writeLine("", self.indentationLevel)

        for innerClass in self.innerClasses:
            innerClassLines = innerClass.generateClassDefinitionLines()
            for innerClassLine in innerClassLines:
                writeLine(innerClassLine, self.indentationLevel)
                    
        writeLine("}", self.indentationLevel)
        
        return lines

class KotlinClass(CodeClass):    
    def __init__(self):
        super().__init__(
            indentationCharacter="    ",
            language= "Kotlin",
            constKeyword= "val"
        )
    
    def createInnerClass(self):
        return KotlinClass()
    

class SwiftClass(CodeClass):    
    def __init__(self):
        super().__init__(
            indentationCharacter="    ",
            language= "Swift",
            constKeyword= "let"
        )
    
    def createInnerClass(self):
        return SwiftClass()


## 
## FILE GENERATION METHODS:
##
def generateStringFromCodeClass(codeClass):
    fileLines = ["// %s file generated by const_creator python script\n" % codeClass.language]
    
    lines = codeClass.generateClassDefinitionLines()
    for line in lines:
        fileLines.append(line)

    classFile = ""    
    for line in fileLines:
        classFile += ("%s\n" % line)

    return classFile
    
def convertToSwiftFile(templateFileJson):    
    templateFileObject = json.loads(templateFileJson)
    
    if (isinstance(templateFileObject, object)):
        swiftClass = SwiftClass()
        swiftClass.parseClassObject(templateFileObject)
        return generateStringFromCodeClass(swiftClass)

    return "invalid json"


def convertToKotlinFile(templateFileJson):    
    templateFileObject = json.loads(templateFileJson)
    
    if (isinstance(templateFileObject, object)):
        swiftClass = KotlinClass()
        swiftClass.parseClassObject(templateFileObject)
        return generateStringFromCodeClass(swiftClass)

    return "invalid json"

if __name__ == '__main__':
    args = sys.argv[1:]
    
    templateFilePath = "_temp/template.json"
    
    if (len(args) != 0):
        templateFilePath = args[0]

    templateFileJson = open(templateFilePath).read()
    
    swiftFile = convertToSwiftFile(templateFileJson)

    print(swiftFile)

    kotlinFile = convertToKotlinFile(templateFileJson)

    print(kotlinFile)